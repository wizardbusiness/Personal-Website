---
import AboutSectionLayout from "../layouts/about-section-layout.astro";
import ScrollCaret from "../components/ScrollCaret.astro";
import Nav from "../components/Nav.astro";
import Skyline from "../components/bgEffects/Skyline";
import Bio from "../components/Bio.astro";
import Portfolio from "../components/Portfolio.astro";
import Tech from "../components/Tech.astro";
import IllHandleTheRest from "../components/flavorText/IllHandleTheRest.astro";
import YouDreamIt from "../components/flavorText/YouDreamIt.astro";
---

<AboutSectionLayout data-info-page slot="info-section">
  <Nav slot="nav" location="info-section" />
  <Skyline slot="skyline" client:load />
  <ScrollCaret slot="caret" section="info" />
  <Bio slot="about" />
  <Portfolio slot="portfolio" />
  <YouDreamIt slot="flav-text-a" />
  <Tech slot="tech" />
  <IllHandleTheRest slot="flav-text-b" />
</AboutSectionLayout>
<script>
  import {
    randomIntFromInterval,
    randomElFromArray,
    randomDecNumFromInterval,
  } from "../scripts/randomFromInterval";
  import { cityParkState } from "../store";
  // only represent values for targetable nodes not all nodes. each pair represents the targetable values for a quadrant
  // css polygons have a percentage based scale where
  // the upper left is 0% 0% and the lower right is 100% 100%, these values represent these.
  const initialNodeValPairs = [
    // upper left, lower left
    [0, 50],
    [50, 100],
    // upper right, lower right
    [100, 50],
    [50, 100],
  ];

  const chooseNodeValues = (nodeValPairs: number[][]) => {
    const targetIndex = randomIntFromInterval(0, nodeValPairs.length - 1); // will randomly select index to modify values at.
    return targetIndex;
  };

  // customizable node values
  const setNodeVals = (targetIndex: number, nodeValuePairs: number[][], probability: number = 0.3) => {
    // set the probability that a modification will take place. currently 30%
    const modCheckPass = Math.random() <= probability ? true : false;
    // if check doesn't pass dont modify any node values
    if (modCheckPass === false) return nodeValuePairs;
    // choose values to modify by target index
    const moddedValues = nodeValuePairs.map((valPair: number[], index) => {
      if (index === targetIndex) {
        // modify the values;
        return valPair.map((value: number) => {
          return randomIntFromInterval(0, 80);
        });
      } else {
        // leave untargeted indexes alone.
        return valPair;
      }
    });
    return moddedValues;
  };

  function calcHeightMod(index: number, min: number, max: number) {
    const noise = randomIntFromInterval(-10, 10);
    const height = 10 * index + 30 * Math.cos((20 * index) ** 1 / 2) + noise;
    const heightClamp = height > max ? randomIntFromInterval(10, height / 2) : 0;
    return height < min ? min : height - heightClamp;
  }

  function generateBuildingState(
    chooseNodeValues,
    setNodeVals,
    initialNodeValPairs,
    index: number,
    delay: number,
    height,
    width,
  ) {
    const nodesToMod = chooseNodeValues(initialNodeValPairs);
    const nodeVals = setNodeVals(nodesToMod, initialNodeValPairs, 0.4);

    const transitionDelay = index * delay;
    return {
      nodeVals,
      height,
      width,
      transitionDelay,
    };
  }

  function generateCityChunkState(
    containerElement: HTMLElement,
    chunkSpanMultiplier: number,
    initialNodeValPairs,
    minHeight: number,
    maxHeight: number,
    minWidth: number,
    maxWidth: number,
    delay: number,
  ) {
    const containerElementWidth = containerElement.getBoundingClientRect().width;
    const totalAvailableWidth = containerElementWidth * chunkSpanMultiplier;
    let chunkState = [];
    let currChunkWidth = 0;
    let index = 0;
    while (currChunkWidth < totalAvailableWidth) {
      const height = calcHeightMod(index, minHeight, maxHeight);
      const width = randomIntFromInterval(minWidth, maxWidth);
      const componentState = generateBuildingState(
        chooseNodeValues,
        setNodeVals,
        initialNodeValPairs,
        index,
        delay,
        height,
        width,
      );
      chunkState.push(componentState);
      currChunkWidth += width;
      index++;
    }

    return chunkState;
  }

  function generateParkTreeState(
    treeHeight: number,
    treeWidth: number,
    minScaleX: number,
    maxScaleX: number,
    minScaleY: number,
    maxScaleY: number,
    minFoliageTranslate: number,
    maxFoliageTranslate: number,
    minOffset: number,
    maxOffset: number,
    colorOpts: string[],
    zIndexOpts: number[],
    flipTrunk: [-1, 1],
    minDelay: number,
    maxDelay: number,
  ) {
    const scaleX = randomElFromArray([minScaleX, maxScaleX]);
    const scaleY = randomDecNumFromInterval(minScaleY, maxScaleY);
    const foliageTranslate = randomIntFromInterval(minFoliageTranslate, maxFoliageTranslate);
    const offset = randomIntFromInterval(minOffset, maxOffset);
    const color = randomElFromArray(colorOpts);
    const zIndex = randomElFromArray(zIndexOpts);
    const trunkFlip = randomElFromArray(flipTrunk);
    const delay = randomIntFromInterval(minDelay, maxDelay);

    return {
      treeHeight,
      treeWidth,
      scaleX,
      scaleY,
      foliageTranslate,
      offset,
      color,
      zIndex,
      trunkFlip,
      delay,
    };
  }

  function generateParkState(
    parkContainer: HTMLElement,
    treeHeight: number,
    treeWidth: number,
    minScaleX: number,
    maxScaleX: number,
    minScaleY: number,
    maxScaleY: number,
    minFoliageTranslate: number,
    maxFoliageTranslate: number,
    minOffset: number,
    maxOffset: number,
    colorOpts: string[],
    zIndexOpts: number[],
    flipTrunk: [-1, 1],
    minDelay: number,
    maxDelay: number,
  ) {
    const parkWidth = Math.round(parkContainer.getBoundingClientRect().width);
    let currParkWidth = 0;
    const park = [];
    while (currParkWidth < parkWidth) {
      const scaleX = randomDecNumFromInterval(minScaleX, maxScaleX);
      const parkTree = generateParkTreeState(
        treeHeight,
        treeWidth,
        minScaleX,
        maxScaleX,
        minScaleY,
        maxScaleY,
        minFoliageTranslate,
        maxFoliageTranslate,
        minOffset,
        maxOffset,
        colorOpts,
        zIndexOpts,
        flipTrunk,
        minDelay,
        maxDelay,
      );
      park.push(parkTree);
      currParkWidth += 20;
    }
    return park;
  }

  const infoSectionContent: HTMLElement = document.querySelector("#info-section-content-group");

  type BuildingSeedData = [number, number[][], number, number, number, number, number];
  const buildingSeedData: BuildingSeedData = [
    1 / 8,
    initialNodeValPairs, // clip path node parameters
    20, // min height
    60, // max height
    15, // min width
    25, // max width);
    85, // delay
  ];

  type ParkSeedData = [
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    number,
    string[],
    number[],
    [-1, 1],
    number,
    number,
  ];

  const parkSeedData: ParkSeedData = [
    40, // tree height
    20, // tree width
    -1, // min scale x
    1, // max scale x
    0.8, // min scale y
    1.3, // max scale y
    10, // min foliage translate
    20, // max foliage translate
    10, // min offset
    15, // max offset
    ["#39455e", "#2B3C56"], // color opts
    [1, 2, 3, 4, 5], // z index opts
    [-1, 1], // flip trunk
    1000, // min delay
    1220, // max delay
  ];

  const skylineLeft = generateCityChunkState(infoSectionContent, ...buildingSeedData);
  const skylineRight = generateCityChunkState(infoSectionContent, ...buildingSeedData);
  function attachDataToElementDataAttribute(dataAttributeStr, data) {
    const elementWithData = document.querySelector(`[${dataAttributeStr}]`);
    elementWithData.setAttribute(dataAttributeStr, data);
  }
  const parkContainer: HTMLElement = document.querySelector("#city-park");

  const cityPark = generateParkState(parkContainer, ...parkSeedData);
  console.log(cityPark);
  cityParkState.set(cityPark);

  const infoSectionCaptionContainer: HTMLElement = document.querySelector("#caption-info-container");
  attachDataToElementDataAttribute(
    "data-skyline-data",
    JSON.stringify({ skylineRight: skylineRight, skylineLeft: skylineLeft }),
  );
</script>
