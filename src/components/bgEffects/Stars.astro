<div class="fixed bottom-0 left-0 -z-10 block h-full w-full animate-fade-in object-contain">
  <canvas id="canvas1" class="fixed bottom-0 left-0 h-full w-full object-contain"> </canvas>
  <canvas id="canvas2" class="fixed bottom-0 left-0 -z-20 h-full w-full animate-fade-in object-contain">
  </canvas>
</div>
<script>
  import {
    generateWeightedRandomInRange,
    generatedWeightedCoords,
    randomElFromArray,
    randomIntFromInterval,
  } from "../../scripts/randomFromInterval";

  const transitionStep = ["", "a", "b", "c", "d", "e", "f", "g"] as const;
  type TransitionStep = (typeof transitionStep)[number];

  const renderCanvas1 = () => {
    const canvas: HTMLCanvasElement = document.querySelector("#canvas1");
    const context = canvas.getContext("2d");

    const pixelRatio = window.devicePixelRatio || 1;
    const height = window.innerHeight * pixelRatio;
    const width = window.innerWidth * pixelRatio;
    canvas.height = height;
    canvas.width = width;
    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);

    // create collision grid
    const createGrid = (canvasHeight: number, canvasWidth: number, cellHeight: number, cellWidth: number) => {
      const grid = [];
      // divide canvas up into cellHeight x cellWidth px cells
      const cellRowsCount = canvasHeight / cellHeight;
      const cellColumnsCount = canvasWidth / cellWidth;
      // cell
      const cellCount = cellRowsCount * cellColumnsCount;
      let currCell = 0;
      let currRow = 0;
      let currColumn = 0;
      interface cell {
        x: number;
        y: number;
        left: number;
        right: number;
        top: number;
        bottom: number;
        id: string;
      }
      const createCell = (id: string, x: number, y: number, width: number, height: number) => {
        const cell: cell = {
          id: id,
          x: x,
          y: y,
          left: x - width / 2,
          right: x + width / 2,
          top: y - height / 2,
          bottom: y + height / 2,
        };
        return cell;
      };
      while (currCell < cellCount) {
        // x y is center of each cell.
        const x = currColumn * cellWidth + cellWidth / 2;
        const y = currRow * cellHeight + cellHeight / 2;
        // use id to check which cells an object occupies
        const id = `c${currColumn}r${currRow}`;
        const cell = createCell(id, x, y, cellWidth, cellHeight);
        grid.push(cell);
        if (currColumn < cellColumnsCount) currColumn++;
        else if (currColumn === cellColumnsCount) {
          currColumn = 0;
          currRow++;
        }
        currCell++;
      }
      return { cells: grid, cellHeight: cellHeight, cellWidth: cellWidth };
    };

    const grid = createGrid(canvas.height, canvas.width, 8, 8); // use powers of two for cell w and h

    const getCellsOccupiedByObj = (grid, object: Star | CollisionObj) => {
      // round object bounds to nearest cell bounds
      const calcCellBounds = (grid, obj) => {
        // check each object outer bound against the height / width of each cell.
        // round to nearest left cell side
        const left = Math.floor(obj.left / grid.cellWidth) * grid.cellWidth;
        const top = Math.floor(obj.top / grid.cellHeight) * grid.cellHeight;
        const right = Math.ceil(obj.right / grid.cellWidth) * grid.cellWidth;
        const bottom = Math.ceil(obj.bottom / grid.cellHeight) * grid.cellHeight;
        return { left, top, right, bottom };
      };

      const occupiedCellBounds = calcCellBounds(grid, object);

      const getOccupiedCellIds = (occupiedCellBounds, cellWidth, cellHeight) => {
        const ids = [];

        const cellsWidth = occupiedCellBounds.right - occupiedCellBounds.left;
        const cellsHeight = occupiedCellBounds.bottom - occupiedCellBounds.top;
        let cellCount = (cellsWidth / cellWidth) * (cellsHeight / cellHeight);
        let currCellLeft = occupiedCellBounds.left;
        let currCellTop = occupiedCellBounds.top;
        while (cellCount > 0) {
          // get row and column of top and left bounds by dividing by cellwidth and height
          const cellRow = Math.floor(currCellTop / cellHeight);
          const cellCol = Math.floor(currCellLeft / cellWidth);
          const cellId = `c${cellCol}r${cellRow}`;
          ids.push(cellId);
          currCellLeft += cellWidth;
          if (currCellLeft === occupiedCellBounds.right) {
            currCellTop += cellHeight;
            currCellLeft = occupiedCellBounds.left;
          }

          cellCount--;
        }
        return ids;
      };

      const cellIds = getOccupiedCellIds(occupiedCellBounds, grid.cellWidth, grid.cellHeight);
      return cellIds;
    };

    const handleCollisions = (grid, object: Star | CollisionObj, collisionMap) => {
      return () => {
        const occupiedCells = getCellsOccupiedByObj(grid, object);
        let collision = false;
        let test = 0;
        for (let i = 0; i < occupiedCells.length; i++) {
          const cellId = occupiedCells[i];
          if (!(cellId in collisionMap)) {
            collisionMap[cellId] = null;
            test++;
          } else if (cellId in collisionMap) {
            collision = true;
          }
        }
        return collision;
      };
    };

    type CollisionObj = {
      top: number;
      right: number;
      bottom: number;
      left: number;
    };

    const convertDivToCollisionObj = (div: Element) => {
      const divArea = div.getBoundingClientRect();
      return {
        top: Math.ceil(divArea.top),
        right: Math.ceil(divArea.right),
        bottom: Math.ceil(divArea.bottom),
        left: Math.ceil(divArea.left),
      };
    };

    const divs = document.querySelectorAll(".collision-obj");
    const divCollisionObjs = Array.from(divs, (el) => convertDivToCollisionObj(el));

    const generateStars = (starCount: number, context: CanvasRenderingContext2D): Star[] => {
      const stars = [];
      // cache an area, so that any coords that fall within the same area are rerun.
      // check if any part of the area overlaps with existing object (within a rectangle)
      const collisionMap = {};
      // preload collision map with any divs you want to avoid collisions with.
      divCollisionObjs.forEach((obj) => handleCollisions(grid, obj, collisionMap)());
      for (let i = 0; i < starCount; i++) {
        const width = Math.floor(generateWeightedRandomInRange(20, 100, 20, 20) / 4);
        const height = width;
        const coords = generatedWeightedCoords(
          innerWidth,
          innerHeight,
          width,
          height,
          200, // variance
          -0.2, // slope
          innerHeight / 3, // intercept
          i,
          starCount,
        );
        const x = coords.x;
        const y = coords.y;
        // don't render stars that are offscreen
        if (x < 0 || y < 0) continue;
        const degreeOffset = randomIntFromInterval(0, 90);
        const animationDur = randomIntFromInterval(800, 1200);
        const star = new Star(x, y, width, height, degreeOffset, animationDur, context);
        const collision = handleCollisions(grid, star, collisionMap)();
        if (!collision) stars.push(star);
      }
      return stars;
    };
    const starCount = Math.floor((window.innerHeight * window.innerWidth) / 3500);
    const stars: Star[] = generateStars(starCount, context);
    const starTrailCanvas: HTMLCanvasElement = document.querySelector("#canvas2");
    const starTrailContext = starTrailCanvas.getContext("2d");
    const starTrailCanvasHeight = window.innerHeight * pixelRatio;
    const starTrailCanvasWidth = window.innerWidth * pixelRatio;
    starTrailCanvas.height = starTrailCanvasHeight;
    starTrailCanvas.width = starTrailCanvasWidth;
    starTrailContext.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);

    const animateStars = () => {
      const captionContainer = document.querySelector("#caption-container");
      const currTransitionStep = captionContainer.getAttribute("data-transition-step") as TransitionStep;
      context.clearRect(0, 0, canvas.width, canvas.height);
      starTrailContext.clearRect(0, 0, starTrailCanvas.width, starTrailCanvas.height);
      stars.forEach((star) => {
        // ANCHOR[id=animateStars]
        // LINK #starClass
        star.twinkle();
        star.drawStarTrail("up", starTrailContext, currTransitionStep);
      });
      requestAnimationFrame(animateStars);
    };
    animateStars();
  };

  const renderCanvas2 = () => {
    const canvas2: HTMLCanvasElement = document.querySelector("#canvas2");
    const context = canvas2.getContext("2d");
    const pixelRatio = window.devicePixelRatio || 1;
    const height = window.innerHeight * pixelRatio;
    const width = window.innerWidth * pixelRatio;
    canvas2.height = height;
    canvas2.width = width;
    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
    let start = { x: 200, y: 200 };
    let end = { x: 200, y: 200 };
    let max = 400;
    let speed = 1;
    let brightness = 10;
    const shootingStar = () => {
      context.clearRect(0, 0, canvas2.width, canvas2.height);
      context.beginPath();
      context.moveTo(start.x, start.y);
      context.lineTo(end.x, end.y);
      if (end.x < max) {
        end.x += speed;
        end.y += speed;
      } else if (end.x >= max) {
        start.x += speed / 2;
        start.y += speed / 2;
        context.globalAlpha = brightness;
        brightness -= 0.1;
      } else if (brightness <= 0) {
        return;
      }
      context.strokeStyle = "lightgray";
      context.stroke();
      requestAnimationFrame(shootingStar);
    };
    // shootingStar();
  };

  // renderCanvas2();

  class Star {
    public brightness: number;
    public dim: boolean;
    public left: number;
    public right: number;
    public top: number;
    public bottom: number;
    public radiusModifiers: number[];
    public radiuses: number[];
    public shapeDegreeMods: number | string | (() => number);
    public animationStart: number;
    public prevFrameTStampMs: number;
    public trail: {
      x: number;
      y: number;
    }[];
    public tail: number;
    public incrementTailBrightness: boolean;
    public tailBrightness: number;

    constructor(
      public x: number,
      public y: number,
      public width: number,
      public height: number,
      public degreeOffset: number,
      public animationDur: number,
      public context: CanvasRenderingContext2D,
    ) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.height = height;
      this.left = Math.floor(x - width / 2);
      this.top = Math.floor(y - height / 2);
      this.right = Math.floor(x + width / 2);
      this.bottom = Math.floor(y + height / 2);
      this.animationStart = Date.now();
      this.prevFrameTStampMs = Date.now();
      this.animationDur = animationDur;
      this.context = context;
      this.brightness = 0.5;
      this.dim = false;
      this.radiusModifiers = [3, 5, 3, 5, 3];
      this.degreeOffset = degreeOffset;
      this.shapeDegreeMods = randomElFromArray([36, 45]);
      this.tail = 0;
      this.incrementTailBrightness = true;
      this.tailBrightness = 0.5;
    }

    stepBetweenValues(a: number, b: number, step: number) {
      let curr = this.tailBrightness;
      let increment = this.incrementTailBrightness;
      if (increment) {
        curr += step;
        if (curr >= b) {
          this.incrementTailBrightness = false;
        }
      } else {
        curr -= step;
        if (curr <= a) {
          this.incrementTailBrightness = true;
        }
      }
      this.tailBrightness = curr;
      return curr;
    }

    /**
     * draws a star shape with 4 inner and 4 outer points, offset by 45 degrees
     */
    draw(xCoord: number, yCoord: number) {
      const getPointsOnCircle = (radiuses, degrees, degreeOffset) => {
        const points = [];
        // create points at regular intervals around circle from initial angle
        const pointCount = 360 / degrees;
        let multiplier = 0;
        let currRadI = 0;
        while (multiplier <= pointCount) {
          if (!radiuses[currRadI + 1]) currRadI = 0;
          const theta = degrees * multiplier * (Math.PI / 180);
          const rotateTheta = degreeOffset * (Math.PI / 180);
          const x = radiuses[currRadI] * Math.cos(theta);
          const y = radiuses[currRadI] * Math.sin(theta);
          const rotatedX = x * Math.cos(rotateTheta) - y * Math.sin(rotateTheta);
          const rotatedY = x * Math.sin(rotateTheta) + y * Math.cos(rotateTheta);
          points.push([rotatedX, rotatedY]);
          multiplier++;
          currRadI++;
        }
        return points;
      };
      const radiuses = this.radiusModifiers.map((radiusFract) => this.width / radiusFract);
      const points = getPointsOnCircle(radiuses, this.shapeDegreeMods, this.degreeOffset);
      this.context.beginPath();
      const drawShapeFromPoints = (points: number[]) => {
        for (let i = 0; i < points.length - 1; i++) {
          const x = points[i][0] + xCoord;
          const y = points[i][1] + yCoord;
          if (i === 0) this.context.moveTo(x, y);
          const nextX = i === points.length - 1 ? points[0][0] + xCoord : points[i + 1][0] + xCoord;
          const nextY = i === points.length - 1 ? points[0][1] + xCoord : points[i + 1][1] + yCoord;

          this.context.lineTo(x, y);
          this.context.lineTo(nextX, nextY);
        }
        this.context.closePath();
        this.context.fillStyle = "lightgray";
        this.context.fill();
      };
      drawShapeFromPoints(points);
    }

    // LINK #animateStars
    // ANCHOR[id=starClass]
    drawStarTrail(
      direction: "up" | "down",
      context: CanvasRenderingContext2D,
      currTransitionStep: TransitionStep,
    ) {
      const tail = direction === "up" ? this.y + this.tail : this.y - this.tail;
      const gradient = context.createRadialGradient(
        this.x,
        this.y,
        Math.floor(this.width / 4),
        this.x,
        tail,
        Math.floor(this.width / 4),
      );

      const brightness = this.stepBetweenValues(0.5, 0.7, 0.003);
      // console.log(brightness);

      gradient.addColorStop(0, "rgb(242, 242, 242, 0)");
      gradient.addColorStop(0.07, `rgb(242, 242, 242, ${brightness})`);
      gradient.addColorStop(0.1 + brightness, "rgb(242, 242, 242, 0.2)");
      gradient.addColorStop(1, "rgb(242, 242, 242, 0)");

      context.beginPath();
      context.moveTo(this.x, this.y);
      context.lineTo(this.x, tail);
      context.lineWidth = this.width - this.width / 5;
      context.strokeStyle = gradient;
      context.stroke();
      switch (currTransitionStep) {
        case "a":
          this.tail -= 0.2;
          break;
        case "b":
          this.tail > -100 ? (this.tail -= 0.9 - this.tail * 0.0009) : this.tail;
          break;
        case "c":
          this.tail > -200 ? (this.tail -= 0.5 - this.tail * 0.006) : this.tail;
          break;
        case "d":
          this.tail < 0 ? (this.tail += 3.4 - this.tail * 0.01) : (this.tail = 0);
          break;
        case "e":
          this.tail < 75 ? (this.tail += 3.2 - this.tail * 0.01) : this.tail;
          break;
        case "f":
          this.tail < 150 ? (this.tail += 3.2 - this.tail * 0.01) : this.tail;
          break;
        case "g":
          this.tail > 0 ? (this.tail -= 3.2 + this.tail * 0.01) : (this.tail = 0);
          break;
        default:
          break;
      }
    }

    twinkle() {
      const currTimeMs = Date.now();
      const elapsedMs = currTimeMs - this.animationStart;
      const msSincePrevFrame = Math.min(currTimeMs - this.prevFrameTStampMs, 20);

      if (elapsedMs > this.animationDur / 2) {
        this.animationStart = Date.now();
        this.dim = !this.dim;
      } else if (elapsedMs <= this.animationDur / 2) {
        if (this.dim) {
          this.radiusModifiers = this.radiusModifiers.map((radius) => {
            if (radius > 7) return;
            return (radius += (2 / this.animationDur / 2) * msSincePrevFrame);
          });
          this.brightness = 0.8 - (0.3 * elapsedMs) / this.animationDur / 2;
        } else if (!this.dim) {
          this.radiusModifiers = this.radiusModifiers.map((radius) => {
            if (radius < 1) return;
            return (radius -= (2 / this.animationDur / 2) * msSincePrevFrame);
          });
          this.brightness = 0.5 + (0.3 * elapsedMs) / this.animationDur / 2;
        }
        this.prevFrameTStampMs = currTimeMs;
      }
      this.context.globalAlpha = this.brightness;
      this.draw(this.x, this.y);
    }
  }

  renderCanvas1();
  // renderCanvas2();
</script>
